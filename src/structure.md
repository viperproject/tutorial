# Structure of Viper Programs

For a type-safe Viper program to be correct, all methods and functions in it must be successfully verified against their specifications. The implementation of a Viper method consists of certain [imperative building blocks](./statements.md) (such as branch conditions, loops, etc.) whereas the specification consists of [assertions](./assertions.md) (contracts, loop invariants, etc.). Statements (or operations) may change the program state, whereas assertions cannot. In contrast, assertions can talk about properties of a particular state â€” so they can be used to specify the behavior of operations. What the implementation and the specification have in common is that they both make use of _expressions_. For all of these building blocks, Viper supports different means of abstraction. 

Methods can be viewed as a means of abstraction over a sequence of operations (i.e. the execution of a potentially-unbounded number of statements). The caller of a method observes its behavior exclusively through the method's signature and its specification (its preconditions and postconditions). Viper method calls are treated modularly: for the caller of a method, the method's implementation can be thought of as invisible. Calling a method may result in modifications to the program state, therefore method calls cannot be used in specifications. On the one hand, the caller of a method must first satisfy the assertions in its precondition in order to obtain the assertions from its postcondition. On the other hand, in order to _verify_ a method itself, Viper must prove that the method's implementation adheres to the method's specification.

Functions can be viewed as a means of abstraction over (potentially state-dependent) expressions. Generally, the caller of a function observes three things. First, the precondition of the function is checked in the state in which the function is called. The precondition may include assertions denoting _resources_, such as [permissions to field locations](./permissions.md) that the the function may read from. Second, the function application's result value is equated with the expression in the function's body (if provided); note that this usage of the function's implementation is a difference from the handling of methods. Third, the function's postconditions are assumed. The postcondition of a function may _not_ contain resource assertions (e.g. denoting field permissions): all resources from the precondition are automatically returned after the function application. Refer to the [section on functions](./functions.md) for more details.

Predicates can be viewed as a means of abstraction over assertions (including resources such as field permissions). The body of a predicate is an assertion. Unlike functions, predicates are not automatically inlined: to replace a predicate with its body, Viper provides an explicit `unfold` statement. An `unfold` is an operation that changes the program state, replacing the predicate resource with the assertions specified by its body. The dual operation is called a `fold`: folding a predicate replaces the resources specified by its body with an instance of the predicate itself. Refer to the [section on predicates](./predicates.md) for more details.

In the next chapter you can find a brief description and examples of the language constructs that can be used to write a Viper program. Note that the order in which top-level declarations are written is not important, as names are resolved against all declarations of the program (including later declarations).
