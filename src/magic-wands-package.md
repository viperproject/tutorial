# Package operations

There are two ways in which a magic wand instance can be added to the resources held in the program state: they can be inhaled (just as any other Viper resource), or we can instruct Viper to construct a new magic wand instance with a `package` statement. As an example to explain the feature, we will consider the `package` before the loop in the code example above. A `package` statement consists of the keyword followed by the desired magic wand instance (in this case, `list(tmp) --* list(l1)`), along with an optional block of code delimited by braces. The role of a `package` statement is to create (and justify the creation of) a new magic wand instance in the following way:

* A subset of the resources held in the _current state_ must be identified as necessary for justifying the new magic wand instance. These must be sufficient resources to ensure that, given the additional resources described in the wand left-hand-side, those on the wand's right-hand-side can be produced. This set of resources is _taken_ from the current state, and is called the _footprint_ of the newly-created magic wand instance. In our example, these are the field permissions `acc(l1.val) && acc(l1.next)` (since, along with the wand's left-hand-side `list(tmp)`, these are sufficient to guarantee the wand's right-hand-side `list(l1)`).
* The `package` operation must check that, given the selected footprint of resources from the current state, in _any heap_ in which the wand's left-hand-side assertion is held, the combination of these resources can be exchanged for the wand right-hand-side. Any field locations framed by permissions in the wand's footprint will be assumed to be unchanged for this check (e.g. `l1.next == tmp` is known in our example, since permission to `l1.next` is in the wand's footprint). The check is made during the `package` operation by successively attempting to match the resources required on the right-hand-side with resources provided on the left; if not found on the left-hand-side, the resources must instead be found in the current state (or else the `package` operation fails with a verification error), and are taken for the wand's footprint. See our [ECOOP'15](http://pm.inf.ethz.ch/publications/getpdf.php?bibname=Own&id=SchwerhoffSummers15.pdf) paper for more details of how wand footprints are chosen.
* It is often the case that the combination of the wand's left-hand-side and footprint do not _directly_ yield the wand's right-hand-side, but instead can do so after a number of additional operations are performed. These operations can be specified in the block attached to the `package` statement. In our example, the wand left-hand-side `list(tmp)` combined with the wand footprint `acc(l1.val) && acc(l1.next)` are sufficient to guarantee `list(l1)` _after_ performing the operation `fold list(l1)`, which is given in the block.

> **Exercise**
> * In the [previous example](./magic-wands.md), add a statement `assert acc(l1.next)` just before the first `package` statement. Run the example; there should be no error. Now try moving your `assert` statement to _after_ the `package` operation (and its attached block). You should now get an assertion failure; the permission to `l1.next` has been used up in the wand's footprint.
> * Try removing the `fold list(l1)` statement from the first `package` statement. What error do you now get, when running the example?
